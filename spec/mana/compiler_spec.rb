# frozen_string_literal: true

require "spec_helper"

RSpec.describe Mana::Compiler do
  let(:cache_dir) { Dir.mktmpdir("mana_test_cache") }

  before do
    described_class.cache_dir = cache_dir
    described_class.clear!
    Mana.config.api_key = "test-key"
  end

  after do
    FileUtils.rm_rf(cache_dir)
  end

  describe ".generate" do
    it "calls the engine and returns generated code" do
      stub_anthropic_sequence(
        [{ type: "tool_use", id: "t1", name: "write_var",
           input: { "name" => "code", "value" => "def greet(name)\n  \"Hello, \#{name}\"\nend" } }],
        [{ type: "tool_use", id: "t2", name: "done", input: {} }]
      )

      result = described_class.generate(:greet, "name", "greet the person by name")
      expect(result).to include("def greet")
      expect(result).to include("Hello")
    end
  end

  describe ".write_cache" do
    it "writes a .rb file to the cache directory" do
      source = "def add(a, b)\n  a + b\nend"
      path = described_class.write_cache(:add, source)

      expect(File.exist?(path)).to be true
      content = File.read(path)
      expect(content).to include("Auto-generated by ruby-mana")
      expect(content).to include("def add(a, b)")
    end

    it "includes owner prefix for class methods" do
      source = "def multiply(a, b)\n  a * b\nend"
      path = described_class.write_cache(:multiply, source, String)

      expect(File.basename(path)).to eq("string_multiply.rb")
    end
  end

  describe ".source" do
    it "returns nil for uncompiled methods" do
      expect(described_class.source(:nonexistent)).to be_nil
    end

    it "returns source after compilation" do
      code = "def test_method\n  42\nend"
      described_class.registry["test_method"] = code
      expect(described_class.source(:test_method)).to eq(code)
    end
  end

  describe ".clear!" do
    it "removes cache directory and clears registry" do
      FileUtils.mkdir_p(cache_dir)
      File.write(File.join(cache_dir, "test.rb"), "# test")
      described_class.registry["test"] = "code"

      described_class.clear!

      expect(Dir.exist?(cache_dir)).to be false
      expect(described_class.registry).to be_empty
    end
  end

  describe ".compile" do
    it "wraps a method for lazy compilation" do
      # Create a test class with a method to compile
      klass = Class.new do
        def square(n)
          ~"return n squared"
        end
      end

      # Stub the LLM to return generated code
      stub_anthropic_sequence(
        [{ type: "tool_use", id: "t1", name: "write_var",
           input: { "name" => "code", "value" => "def square(n)\n  n * n\nend" } }],
        [{ type: "tool_use", id: "t2", name: "done", input: {} }]
      )

      described_class.compile(klass, :square)

      obj = klass.new
      result = obj.square(5)
      expect(result).to eq(25)

      # Verify cache file was written
      cache_files = Dir.glob(File.join(cache_dir, "*.rb"))
      expect(cache_files.length).to eq(1)
      expect(File.read(cache_files.first)).to include("n * n")
    end
  end

  describe "describe_params" do
    it "handles various parameter types" do
      klass = Class.new do
        def complex(a, b = 1, *rest, key:, opt: nil, **kwargs, &block); end
      end

      method = klass.instance_method(:complex)
      result = described_class.send(:describe_params, method)
      expect(result).to eq("a, b=nil, *rest, key:, opt: nil, **kwargs, &block")
    end

    it "handles no parameters" do
      klass = Class.new do
        def simple; end
      end

      method = klass.instance_method(:simple)
      result = described_class.send(:describe_params, method)
      expect(result).to eq("")
    end
  end
end
