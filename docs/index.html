<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ruby-mana ğŸ”® â€” Embed LLM as Native Ruby</title>
  <meta name="description" content="Natural language strings that read/write Ruby variables, call functions, and control flow. LLM as a first-class language construct.">
  <meta property="og:title" content="ruby-mana â€” Embed LLM as Native Ruby">
  <meta property="og:description" content="Not an API wrapper. A language construct that weaves LLM into Ruby code.">
  <style>
    :root { --bg:#0d1117; --sf:#161b22; --bd:#30363d; --tx:#e6edf3; --dim:#8b949e; --ac:#a371f7; --ac2:#f778ba; --ac3:#79c0ff; --gr:#3fb950; --or:#d29922; }
    *{margin:0;padding:0;box-sizing:border-box}
    body{font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Helvetica,Arial,sans-serif;background:var(--bg);color:var(--tx);line-height:1.6}
    a{color:var(--ac3);text-decoration:none} a:hover{text-decoration:underline}
    code,pre{font-family:'SF Mono','Fira Code',monospace}
    .c{max-width:880px;margin:0 auto;padding:0 24px}
    nav{position:sticky;top:0;z-index:100;background:rgba(13,17,23,.85);backdrop-filter:blur(12px);border-bottom:1px solid var(--bd);padding:12px 0}
    nav .c{display:flex;align-items:center;justify-content:space-between}
    nav .logo{font-weight:700;font-size:1.1rem} nav .logo .m{color:var(--ac)}
    nav .lk{display:flex;gap:20px;font-size:.9rem} nav .lk a{color:var(--dim)} nav .lk a:hover{color:var(--tx);text-decoration:none}
    .hero{text-align:center;padding:100px 0 70px;position:relative}
    .hero::before{content:'';position:absolute;top:-200px;left:50%;transform:translateX(-50%);width:700px;height:700px;background:radial-gradient(circle,rgba(163,113,247,.12) 0%,transparent 70%);pointer-events:none}
    .hero h1{font-size:3.5rem;font-weight:800;letter-spacing:-.03em;margin-bottom:16px} .hero h1 .m{color:var(--ac)}
    .hero .tl{font-size:1.25rem;color:var(--dim);max-width:520px;margin:0 auto 12px}
    .hero .sub{font-size:.95rem;color:var(--dim);margin-bottom:40px} .hero .sub em{color:var(--ac2);font-style:normal}
    .badges{display:flex;gap:8px;justify-content:center;margin-bottom:36px}
    .badge{padding:4px 12px;border-radius:20px;font-size:.8rem;border:1px solid var(--bd);color:var(--dim)}
    pre{background:var(--sf);border:1px solid var(--bd);border-radius:10px;padding:20px 24px;overflow-x:auto;font-size:.88rem;line-height:1.7}
    .hero-code{display:inline-block;max-width:620px;width:100%;text-align:left}
    .kw{color:var(--ac2)} .str{color:#a5d6ff} .ms{color:var(--gr);font-weight:500} .cmt{color:var(--dim)} .num{color:var(--or)} .fn{color:#d2a8ff}
    section{padding:60px 0} section h2{font-size:2rem;font-weight:700;margin-bottom:12px;letter-spacing:-.02em}
    .lead{color:var(--dim);font-size:1.05rem;margin-bottom:32px;max-width:600px}
    .grid{display:grid;grid-template-columns:1fr 1fr;gap:16px;margin-top:24px}
    .card{background:var(--sf);border:1px solid var(--bd);border-radius:10px;padding:20px 24px}
    .card h3{font-size:1rem;margin-bottom:6px} .card p{font-size:.88rem;color:var(--dim)}
    .card code{color:var(--gr);font-size:.85rem}
    .cmp>div{background:var(--sf);border:2px solid var(--bd);border-radius:10px;padding:20px 24px}
    .cmp>div h3{font-size:.95rem;margin-bottom:12px;color:var(--dim)}
    .cmp>div:last-child{border-color:var(--ac)} .cmp>div:last-child h3{color:var(--ac)}
    .ex{margin-top:32px} .ex h3{font-size:1.15rem;margin-bottom:12px} .ex p{font-size:.9rem;color:var(--dim);margin-bottom:12px}
    .steps{margin-top:24px} .step{display:flex;gap:16px;padding:16px 0;border-bottom:1px solid var(--bd)} .step:last-child{border-bottom:none}
    .sn{flex-shrink:0;width:32px;height:32px;border-radius:50%;background:var(--ac);color:var(--bg);font-weight:700;display:flex;align-items:center;justify-content:center;font-size:.85rem}
    .st{font-size:.92rem} .st strong{color:var(--tx)}
    .ib{background:var(--sf);border:1px solid var(--bd);border-radius:10px;padding:16px 24px;display:inline-block;font-size:1rem;margin-bottom:12px}
    .ib .d{color:var(--dim);user-select:none}
    footer{border-top:1px solid var(--bd);padding:40px 0;text-align:center;color:var(--dim);font-size:.85rem}
    footer a{color:var(--dim)} footer a:hover{color:var(--tx)}
    @media(max-width:640px){.hero h1{font-size:2.2rem} .grid,.cmp{grid-template-columns:1fr}}
  </style>
</head>
<body>

<nav>
  <div class="c">
    <div class="logo">ruby-<span class="m">mana</span> ğŸ”®</div>
    <div class="lk">
      <a href="#features">Features</a>
      <a href="#examples">Examples</a>
      <a href="#how">How it works</a>
      <a href="https://github.com/carlnoah6/ruby-mana">GitHub</a>
      <a href="https://rubygems.org/gems/ruby-mana">RubyGems</a>
    </div>
  </div>
</nav>

<div class="c">

<!-- Hero -->
<div class="hero">
  <h1>ruby-<span class="m">mana</span> ğŸ”®</h1>
  <p class="tl">Embed LLM as native Ruby. Write natural language, it just runs.</p>
  <p class="sub"><em>Not an API wrapper.</em> A language construct that weaves LLM into your code.</p>
  <div class="badges">
    <span class="badge">Ruby 3.3+</span>
    <span class="badge">Anthropic Claude</span>
    <span class="badge">MIT License</span>
  </div>
  <pre class="hero-code"><span class="kw">require</span> <span class="str">"mana"</span>

numbers = [<span class="num">1</span>, <span class="str">"2"</span>, <span class="str">"three"</span>, <span class="str">"cuatro"</span>, <span class="str">"äº”"</span>]
<span class="ms">~"compute the semantic average of &lt;numbers&gt; and store in &lt;result&gt;"</span>
puts result  <span class="cmt"># =&gt; 3.0</span></pre>
</div>

<!-- What makes it different -->
<section>
  <h2>What makes it different</h2>
  <p class="lead">Mana turns LLM into a Ruby co-processor. Your natural language strings can read and write live Ruby state.</p>
  <div class="grid cmp">
    <div>
      <h3>Traditional LLM wrapper</h3>
<pre style="border:none;margin:0;background:none;">client = LLM::Client.new
response = client.chat(
  <span class="str">"Classify: #{email.subject}"</span>
)
data = JSON.parse(response)
email.category = data[<span class="str">"category"</span>]
email.priority = data[<span class="str">"priority"</span>]</pre>
    </div>
    <div>
      <h3>ruby-mana</h3>
<pre style="border:none;margin:0;background:none;"><span class="ms">~"read &lt;email&gt; subject and body, set its category and priority"</span>

<span class="cmt"># That's it. email.category and email.priority are set.</span></pre>
    </div>
  </div>
</section>

<!-- Features -->
<section id="features">
  <h2>Features</h2>
  <div class="grid">
    <div class="card">
      <h3>ğŸ”® <code>~"..."</code> syntax</h3>
      <p>One character turns any string into an LLM prompt that operates on live Ruby state. Variables, objects, functions â€” all accessible.</p>
    </div>
    <div class="card">
      <h3>ğŸ“– Bidirectional binding</h3>
      <p>LLM reads your variables with <code>&lt;var&gt;</code>, writes back with <code>write_var</code>. No serialization, no parsing â€” direct access to the Ruby binding.</p>
    </div>
    <div class="card">
      <h3>âš¡ Custom effects</h3>
      <p>Define your own tools with <code>Mana.define_effect</code>. Block params become the tool schema. LLM calls them like native functions.</p>
    </div>
    <div class="card">
      <h3>ğŸ§¬ LLM compiler</h3>
      <p><code>mana def</code> generates method implementations on first call, caches as real <code>.rb</code> files. Subsequent calls are pure Ruby â€” zero API cost.</p>
    </div>
    <div class="card">
      <h3>ğŸ” Source introspection</h3>
      <p>Prism AST parser auto-discovers your methods and their signatures. LLM knows what functions are available without you listing them.</p>
    </div>
    <div class="card">
      <h3>ğŸ›¡ï¸ Effect system</h3>
      <p>Built on algebraic effects theory. 6 built-in effects (read/write var, read/write attr, call func, done) + unlimited custom effects.</p>
    </div>
  </div>
</section>

<!-- Examples -->
<section id="examples">
  <h2>Examples</h2>

  <div class="ex">
    <h3>Variables â€” read and write</h3>
    <p>Use <code>&lt;var&gt;</code> to reference variables. Existing ones are read, new ones are created.</p>
<pre>name = <span class="str">"Alice"</span>
scores = [<span class="num">85</span>, <span class="num">92</span>, <span class="num">78</span>, <span class="num">95</span>, <span class="num">88</span>]

<span class="ms">~"analyze &lt;scores&gt; for &lt;name&gt;, store mean in &lt;average&gt; and a comment in &lt;comment&gt;"</span>

puts average  <span class="cmt"># =&gt; 87.6</span>
puts comment  <span class="cmt"># =&gt; "Excellent and consistent performance"</span></pre>
  </div>

  <div class="ex">
    <h3>Function calling</h3>
    <p>LLM discovers and calls your Ruby methods automatically via source introspection.</p>
<pre><span class="kw">def</span> <span class="fn">fetch_price</span>(symbol)
  { <span class="str">"AAPL"</span> =&gt; <span class="num">189.5</span>, <span class="str">"GOOG"</span> =&gt; <span class="num">141.2</span>, <span class="str">"TSLA"</span> =&gt; <span class="num">248.9</span> }[symbol] || <span class="num">0</span>
<span class="kw">end</span>

portfolio = [<span class="str">"AAPL"</span>, <span class="str">"GOOG"</span>, <span class="str">"TSLA"</span>]
<span class="ms">~"call fetch_price for each in &lt;portfolio&gt;, store the sum in &lt;total&gt;"</span>
puts total  <span class="cmt"># =&gt; 579.6</span></pre>
  </div>

  <div class="ex">
    <h3>Custom effect handlers</h3>
    <p>Define your own tools. Block keyword params become the tool's input schema.</p>
<pre>Mana.define_effect <span class="str">:query_db</span>,
  description: <span class="str">"Execute a SQL query"</span> <span class="kw">do</span> |sql:|
    ActiveRecord::Base.connection.execute(sql).to_a
  <span class="kw">end</span>

<span class="ms">~"find the 5 most recent orders using query_db, store in &lt;orders&gt;"</span>
orders.each { |o| puts o[<span class="str">"id"</span>] }</pre>
  </div>

  <div class="ex">
    <h3>LLM-compiled methods</h3>
    <p>LLM writes the implementation once, caches it as a real <code>.rb</code> file. After that, pure Ruby.</p>
<pre><span class="kw">mana def</span> <span class="fn">fizzbuzz</span>(n)
  <span class="ms">~"return an array of FizzBuzz results from 1 to n"</span>
<span class="kw">end</span>

fizzbuzz(<span class="num">15</span>)  <span class="cmt"># first call â†’ LLM generates â†’ .mana_cache/fizzbuzz.rb</span>
fizzbuzz(<span class="num">20</span>)  <span class="cmt"># pure Ruby, zero API cost</span>

puts Mana.source(<span class="str">:fizzbuzz</span>)  <span class="cmt"># view the generated code</span></pre>
  </div>

  <div class="ex">
    <h3>Object manipulation</h3>
    <p>LLM reads and writes object attributes directly.</p>
<pre><span class="kw">class</span> Email
  <span class="kw">attr_accessor</span> <span class="str">:subject</span>, <span class="str">:body</span>, <span class="str">:category</span>, <span class="str">:priority</span>
<span class="kw">end</span>

email = Email.new
email.subject = <span class="str">"URGENT: Server down"</span>
email.body = <span class="str">"Database connection pool exhausted..."</span>

<span class="ms">~"read &lt;email&gt; subject and body, set its category and priority"</span>
puts email.category  <span class="cmt"># =&gt; "infrastructure"</span>
puts email.priority  <span class="cmt"># =&gt; "critical"</span></pre>
  </div>
</section>

<!-- How it works -->
<section id="how">
  <h2>How it works</h2>
  <p class="lead">Mana uses Ruby's unary <code>~</code> operator and algebraic effects to bridge natural language and code.</p>
  <div class="steps">
    <div class="step">
      <div class="sn">1</div>
      <div class="st"><strong>~"..." triggers String#~@</strong> â€” captures the caller's Binding via <code>binding_of_caller</code></div>
    </div>
    <div class="step">
      <div class="sn">2</div>
      <div class="st"><strong>Parse &lt;var&gt; references</strong> â€” reads existing variables as context, discovers available methods via Prism AST</div>
    </div>
    <div class="step">
      <div class="sn">3</div>
      <div class="st"><strong>Send to LLM with tools</strong> â€” 6 built-in effects + any custom effects registered via <code>define_effect</code></div>
    </div>
    <div class="step">
      <div class="sn">4</div>
      <div class="st"><strong>Execute tool calls</strong> â€” LLM responds with tool calls â†’ Mana executes against the live Ruby binding â†’ sends results back</div>
    </div>
    <div class="step">
      <div class="sn">5</div>
      <div class="st"><strong>Loop until done</strong> â€” LLM calls <code>done</code> or returns without tool calls. Variables are set, objects are modified, functions were called.</div>
    </div>
  </div>
</section>

<!-- Install -->
<section>
  <h2>Install</h2>
  <div class="ib"><code><span class="d">$ </span>gem install ruby-mana</code></div>
  <p style="color:var(--dim);font-size:.9rem;margin-bottom:8px">Or in your Gemfile: <code>gem "ruby-mana"</code></p>
  <p style="color:var(--dim);font-size:.9rem">Requires Ruby 3.3+ and <code>ANTHROPIC_API_KEY</code> environment variable.</p>
</section>

<!-- Research -->
<section>
  <h2>Research</h2>
  <p class="lead">Mana is inspired by MIT's Nightjar project and the theory of algebraic effects and handlers.</p>
  <p style="color:var(--dim);font-size:.9rem;line-height:1.8">
    ğŸ“„ <a href="https://arxiv.org/abs/2512.14805">Sharing State Between Prompts and Programs</a> â€” the paper behind this approach<br>
    ğŸ <a href="https://github.com/psg-mit/nightjarpy">nightjarpy</a> â€” MIT's Python implementation<br>
    ğŸ’ ruby-mana â€” the Ruby implementation, with <code>~"..."</code> syntax, effect system, and LLM compiler
  </p>
</section>

<!-- Footer -->
<footer>
  <p>
    <a href="https://github.com/carlnoah6/ruby-mana">GitHub</a> Â·
    <a href="https://rubygems.org/gems/ruby-mana">RubyGems</a> Â·
    MIT License
  </p>
  <p style="margin-top:8px">Ruby 3.3+ Â· Built with algebraic effects</p>
</footer>

</div>
</body>
</html>
