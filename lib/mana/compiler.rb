# frozen_string_literal: true

require "fileutils"

module Mana
  # Compiler for `mana def` — LLM generates method implementations on first call,
  # caches them as real .rb files, and replaces the method with native Ruby.
  #
  # Usage:
  #   mana def fizzbuzz(n)
  #     ~"return an array of FizzBuzz results from 1 to n"
  #   end
  #
  #   fizzbuzz(15)  # first call → LLM generates code → cached → executed
  #   fizzbuzz(20)  # subsequent calls → pure Ruby, zero API overhead
  #
  #   Mana.source(:fizzbuzz)  # view generated source
  module Compiler
    class << self
      # Registry of compiled method sources: { "ClassName#method" => source_code }
      def registry
        @registry ||= {}
      end

      # Cache directory for generated .rb files
      def cache_dir
        @cache_dir || ".mana_cache"
      end

      attr_writer :cache_dir

      # Get the generated source for a compiled method
      def source(method_name, owner: nil)
        key = registry_key(method_name, owner)
        registry[key]
      end

      # Compile a method: wrap it so first invocation triggers LLM code generation
      def compile(owner, method_name)
        original = owner.instance_method(method_name)
        compiler = self
        key = registry_key(method_name, owner)

        # Read the prompt from the original method body
        prompt = extract_prompt(original)

        # Build parameter signature for the generated method
        params_desc = describe_params(original)

        owner.define_method(method_name) do |*args, **kwargs, &blk|
          # Generate implementation via LLM
          generated = compiler.generate(method_name, params_desc, prompt)

          # Write to cache file
          cache_path = compiler.write_cache(method_name, generated, owner)

          # Store in registry
          compiler.registry[key] = generated

          # Load the file — this redefines the method with pure Ruby
          load cache_path

          # Call the now-native method
          send(method_name, *args, **kwargs, &blk)
        end
      end

      # Generate Ruby method source via LLM
      def generate(method_name, params_desc, prompt)
        b = binding
        engine_prompt = "Write a Ruby method definition `def #{method_name}(#{params_desc})` that: #{prompt}. " \
                        "Return ONLY the complete method definition (def...end), no explanation. " \
                        "Store the code as a string in <code>"

        Mana::Engine.run(engine_prompt, b)
        b.local_variable_get(:code)
      end

      # Write generated code to a cache file, return the path
      def write_cache(method_name, source, owner = nil)
        FileUtils.mkdir_p(cache_dir)
        prefix = owner && owner != Object ? "#{underscore(owner.name)}_" : ""
        path = File.join(cache_dir, "#{prefix}#{method_name}.rb")
        File.write(path, "# Auto-generated by ruby-mana\n# frozen_string_literal: true\n\n#{source}\n")
        path
      end

      # Clear all cached files and registry
      def clear!
        FileUtils.rm_rf(cache_dir) if Dir.exist?(cache_dir)
        @registry = {}
      end

      private

      def registry_key(method_name, owner = nil)
        if owner && owner != Object
          "#{owner}##{method_name}"
        else
          method_name.to_s
        end
      end

      # Extract the prompt string from the original method.
      # The method body should be a single ~"..." expression.
      def extract_prompt(unbound_method)
        source_loc = unbound_method.source_location
        return nil unless source_loc

        file, line = source_loc
        return nil unless file && File.exist?(file)

        lines = File.readlines(file)
        # Scan from the def line to find the prompt string
        body_lines = []
        depth = 0
        (line - 1...lines.length).each do |i|
          l = lines[i]
          depth += l.scan(/\bdef\b|\bdo\b|\bclass\b|\bmodule\b|\bif\b|\bunless\b|\bcase\b|\bwhile\b|\buntil\b|\bbegin\b/).length
          depth -= l.scan(/\bend\b/).length
          body_lines << l
          break if depth <= 0
        end

        # Extract string content from ~"..." pattern
        body = body_lines.join
        match = body.match(/~"([^"]*)"/) || body.match(/~'([^']*)'/)
        match ? match[1] : body_lines[1...-1].join.strip
      end

      def describe_params(unbound_method)
        unbound_method.parameters.map do |(type, name)|
          case type
          when :req then name.to_s
          when :opt then "#{name}=nil"
          when :rest then "*#{name}"
          when :keyreq then "#{name}:"
          when :key then "#{name}: nil"
          when :keyrest then "**#{name}"
          when :block then "&#{name}"
          else name.to_s
          end
        end.join(", ")
      end

      def underscore(str)
        str.gsub("::", "_")
           .gsub(/([A-Z]+)([A-Z][a-z])/, '\1_\2')
           .gsub(/([a-z\d])([A-Z])/, '\1_\2')
           .downcase
      end
    end
  end
end
